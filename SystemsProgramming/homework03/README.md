Homework 03
Eugene Choi

===========

Activity 1
In the case of -h flag, I used an if statement to check if $1 was equal to "-h" and echoed the usage text. To determine the amount of rotation, I first used an if statement to see if there were any arguments at all; if there wasn't, then the rotation number was the default number, 13. If there was an argument, $ROTATE was set to the value of the argument and was checked to see if it was greater than 26. If it was greater, then the actual rotation number was set to (given rotation % 26). If not, the given number was just used to rotate. 
The source set actually consisted of 2 variables, one a set of lowercase letters, and the other a set of uppercase letters. After transforming the lowercase letters by assigning numbers and shifting them down, the result was pipelined to transform the uppercase letters which used the same method. 

Activity 2
I used a while loop to parse the command line arguments. While the number of arguments was greater than 0, the arguments would be sifted through by a case structure. If the argument was -h, it would call the usage function to display the usage message and then exit. If the argument was -W or -d, it would take the next argument as the appropriate variable ($DELIM, delimiter for comments, or $WFLAG, which determines whether -W was used). Then, the argument to be looked would be shifted. At the end of the while loop, the arguments would be shifted again. To remove the comments, I used a variable $DELIM to store the delimiters. Then, I used sed to substitute any instances of $DELIM and anything after it ('$DELIM.*') with a blank. To remove empty lines, I used sed to find any lines where the end of line character was the first thing in the line ('^$') and substituted it with a blank. If -W was called, the program removed comments and trailing whitespace but not empty lines. If -d was called, the given $DELIM was stored and the comments would be deleted appropriately. 

Activity 3
I used a while loop to parse the arguments similarly to my broify.sh. While the number of arguments was greater than 0, a case structure was used to look through every argument. If -c was called, the next argument was stored in $CITY, and the arguments were shifted. If -s was called, the next argument was stored in $STATE, and the arguments were shifted. If -f was called, the next argument was stored in $FORMAT, and the arguments were shifted. If -h was called, the usage function was called which displays the usage message and exits. I extracted the zip codes with curl, using the same exact command given in the homework document except the URL would contain the state name, then pipelining into a series of grep commands. If the city name was given, it would be grepped for the city, then 'zip', then a 5-digit number, and finally sorted and uniq'd. If the city name was not given, the process was exactly the same without the first procedure. If the format was not given or was specified to be "text", the result was just printed. If the format was given to be csv, then tr command was used to get rid of newlines (\n) and replacing them with ", ". 